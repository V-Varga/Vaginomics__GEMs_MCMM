function model = cleanGrRulesGenes(model)
% cleanGrRulesGenes  Cleans and standardizes the gene-reaction rules (grRules) in a model.
%
% USAGE:
%   model = cleanGrRulesGenes(model)
%
% INPUT:
%   model - RAVEN or COBRA-style model structure with:
%           • model.genes   - cell array of gene IDs
%           • model.grRules - cell array of gene-reaction rules, each rule
%                             is a string containing gene IDs combined by "and" / "or"
%
% OUTPUT:
%   model - The same model, but with:
%           • grRules containing only valid gene IDs present in model.genes
%           • All recognized gene IDs replaced with canonical names
%           • Removed stray logical operators or malformed tokens
%
% PURPOSE:
%   During model reconstruction or merging, grRules can contain:
%     • Gene IDs not present in model.genes
%     • Variations in naming (e.g., missing prefixes like "Lcrispatus_")
%     • Malformed entries starting with "or"/"and"
%   These issues break consistency checks and SBML export.
%
%   This function:
%     1. Builds a mapping from known gene IDs to their canonical form
%     2. Parses grRules into individual tokens (genes and logical operators)
%     3. Cleans and standardizes gene tokens
%     4. Removes tokens not found in the gene list
%     5. Rebuilds the grRule string
%
% EXAMPLE:
%   model = cleanGrRulesGenes(model);
%
% See also: fixSubsystemsField, mergeDuplicateMetNames
% 
% This code was generated by ChatGPT.

    %--------------------------------------------------------------
    % 1. Create mapping from gene names to canonical form
    %--------------------------------------------------------------
    % containers.Map allows quick lookup by string key
    mapping = containers.Map('KeyType','char','ValueType','char');
    
    % Loop over all genes in the model
    for i = 1:numel(model.genes)
        g = model.genes{i};
        
        % Map exact gene name to itself
        mapping(g) = g;
        
        % Also map a "bare" version without the Lcrispatus_ prefix
        % This allows us to match grRules that omit the prefix
        bare = regexprep(g, '^Lcrispatus_', '');
        mapping(bare) = g;
    end

    %--------------------------------------------------------------
    % 2. Loop through each reaction's grRule and clean it
    %--------------------------------------------------------------
    for r = 1:numel(model.grRules)
        % Skip empty rules
        if isempty(model.grRules{r}), continue; end

        %----------------------------------------------------------
        % 2.1 Tokenize the grRule into genes and logical operators
        %----------------------------------------------------------
        % Split at " or " and " and ", keeping only gene tokens
        tokens = regexp(model.grRules{r}, '\s+or\s+|\s+and\s+', 'split');
        
        % Extract the actual logical operators separately
        logicOps = regexp(model.grRules{r}, '\s+(or|and)\s+', 'match');

        %----------------------------------------------------------
        % 2.2 Clean each gene token
        %----------------------------------------------------------
        for t = 1:numel(tokens)
            tok = strtrim(tokens{t});  % remove whitespace

            % Remove accidental leading "or" (e.g., "orGeneX")
            tok = regexprep(tok, '^or', '');
            tok = strtrim(tok);

            % Replace token with its canonical mapped name if found
            if isKey(mapping, tok)
                tokens{t} = mapping(tok);
            else
                % If gene not in mapping, warn and remove it
                warning('Gene "%s" in grRules not found in model.genes — removing', tok);
                tokens{t} = '';
            end
        end

        %----------------------------------------------------------
        % 2.3 Remove empty tokens and rebuild cleaned grRule
        %----------------------------------------------------------
        nonemptyTokens = tokens(~cellfun(@isempty, tokens));

        if isempty(nonemptyTokens)
            % No valid genes left → clear rule
            model.grRules{r} = '';
        else
            % Start with the first token
            newRule = nonemptyTokens{1};

            % Append logical operators and remaining tokens in order
            for j = 1:numel(logicOps)
                newRule = [newRule ' ' logicOps{j} ' ' nonemptyTokens{j+1}];
            end

            % Trim any stray whitespace
            model.grRules{r} = strtrim(newRule);
        end
    end
end
